<!DOCTYPE html>
<html lang="es">
<head>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2x2x2</title>
    <style>
        /* ==== ESTILOS GENERALES ==== */
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column; /* Apila cubo arriba y controles abajo */
        }

        /* ==== CONTENEDOR PRINCIPAL DEL CUBO ==== */
        .cubo-container {
            flex: 2; /* Ocupa m√°s espacio que los controles */
            background-color: #d6eaf8;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Necesario para posicionar la ventanita flotante */
        }

        /* ==== CONTENEDOR DE LOS CONTROLES ==== */
        .controles-container {
            flex: 1; /* Ocupa menos espacio que el cubo */
            background-color: #e5e7e9;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 20px;
        }

        /* ==== SECCIONES DE CONTROLES ==== */
        .seccion {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .seccion h3 {
                margin-bottom: 10px;
            }

        .botones {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        /* ==== ESTILOS DE BOTONES ==== */
        button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            min-width: 50px;
        }

        /* Bot√≥n de toggle prima */
        #toggle {
            margin-top: 10px;
            background-color: #aed6f1;
            border: none;
        }

        /* Bot√≥n para mostrar/ocultar atajos */
        .atajos-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        /* Bot√≥n activado (ej. timer encendido) */
        button.activo {
            background-color: #5dade2;
            color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Ventana flotante lateral */
        .mini-ventana {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 270px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: height 0.3s ease; /* Animaci√≥n suave al abrir/cerrar */
        }

        .toggle-ventana {
            background-color: white;
            border: none;
            font-size: 15px;
            padding: 5px 10px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            border-bottom: 1px solid #ccc;
        }

        .contenido-ventana {
            background-color: #d6eaf8;
            padding: 10px;
            flex: 1;
            font-size: 14px;
            color: #333;
        }

        #cuboCanvasContainer {
            width: 810px;
            aspect-ratio: 1 / 1; /* Mantiene proporci√≥n 1:1 */
            max-height: 320px;
            overflow: hidden;
            position: relative;
        }

        #advertenciaTexto.activo {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- ==== ZONA DEL CUBO ==== -->
    <div class="cubo-container">
        <!-- Bot√≥n para mostrar/ocultar atajos -->
        <div class="atajos-toggle">
            <button id="verAtajosBtn">Ver atajos</button>
            <input type="checkbox" id="movimientoCheckbox">
                x8 veces m√°s r√°pido
        </div>
        

        <div id="cuboCanvasContainer"></div>

        <!-- Ventana flotante con vista alternativa -->
        <div class="mini-ventana" id="miniVentana">
            <button class="toggle-ventana" id="toggleVentana">v</button>
            <div class="contenido-ventana">
                <p>Vista alternativa del cubo (placeholder)</p>
            </div>
        </div>
    </div>

    <!-- ==== CONTROLES PRINCIPALES ==== -->
    <div class="controles-container">
        <!-- Notaci√≥n de movimientos (U, D, R, etc.) -->
        <div class="seccion">
            <h3>Notaci√≥n del Cubo</h3>
            <div class="botones" id="notacion-botones">
                <!-- Botones generados din√°micamente con JS -->
            </div>
        </div>

        <!-- Utilidades extra (timer, revolver, resolver...) -->
        <div class="seccion utilidades">
            <h3>Utilidades</h3>
            <div class="botones" id="utilidad-botones">
                <!-- Botones generados por JS -->
            </div>
        </div>

        <!-- Controles de c√°mara (rotar cubo) -->
        <div class="seccion">
            <h3>Controles de C√°mara</h3>
            <div class="botones" id="camara-botones">
                <!-- Botones generados por JS -->
                <button>‚Üê</button>
                <button>‚Üí</button>
                <button>‚Üë</button>
                <button>‚Üì</button>
                <button>‚Ü∫</button>
                <button>‚Üª</button>
            </div>
        </div>
    </div>

    <script>
        let moveTime = 400;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.set(1, 1, 1.4); // vista desde una esquina
        camera.lookAt(0, 0, 0);       // enfoca al centro del cubo


        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const canvasContainer = document.getElementById('cuboCanvasContainer');
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.setClearColor(0x000000, 0); // color negro con opacidad 0

        canvasContainer.appendChild(renderer.domElement);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        });

        const cubitos = [];
        const size = 0.9; // tama√±o de cada cubito
        const offset = size + 0.05; // espacio entre cubitos

        function rotarCara(movimiento, sentidoHorario = true) {
            const umbral = 0.01;
            let cara = [];

            // Selecci√≥n de cubitos seg√∫n la cara
            switch (movimiento) {
                case 'U':
                    cara = cubitos.filter(c => Math.abs(c.position.y - 0) < umbral);
                    break;
                case 'D':
                    cara = cubitos.filter(c => Math.abs(c.position.y + offset) < umbral);
                    break;
                case 'R':
                    cara = cubitos.filter(c => Math.abs(c.position.x - 0) < umbral);
                    break;
                case 'L':
                    cara = cubitos.filter(c => Math.abs(c.position.x + offset) < umbral);
                    break;
                case 'F':
                    cara = cubitos.filter(c => Math.abs(c.position.z - 0) < umbral);
                    break;
                case 'B':
                    cara = cubitos.filter(c => Math.abs(c.position.z + offset) < umbral);
                    break;
                default:
                    return;
            }

            // Calcular centro de la cara
            const centro = new THREE.Vector3();
            cara.forEach(c => centro.add(c.position));
            centro.divideScalar(cara.length);

            // Crear grupo en el centro
            const grupo = new THREE.Group();
            grupo.position.copy(centro);
            scene.add(grupo);

            // Reubicar cubitos como hijos del grupo
            cara.forEach(c => {
                c.updateMatrixWorld(true);
                c.position.sub(centro); // trasladar al origen del grupo
                grupo.add(c);
                scene.remove(c);
            });

            // Eje de rotaci√≥n
            let eje = new THREE.Vector3();
            switch (movimiento) {
                case 'U':
                case 'D':
                    eje.set(0, 1, 0);
                    break;
                case 'R':
                case 'L':
                    eje.set(1, 0, 0);
                    break;
                case 'F':
                case 'B':
                    eje.set(0, 0, 1);
                    break;
            }

            // Sentido de rotaci√≥n
            let sentido = sentidoHorario;
            if (['L', 'D', 'B'].includes(movimiento)) {
                sentido = !sentidoHorario;
            }
            const anguloTotal = sentido ? -Math.PI / 2 : Math.PI / 2;

            const duracion = moveTime;
            const inicio = Date.now();

            function animar() {
                const ahora = Date.now();
                const progreso = Math.min((ahora - inicio) / duracion, 1);
                const anguloActual = anguloTotal * progreso;

                grupo.rotation.set(0, 0, 0);
                grupo.rotateOnAxis(eje, anguloActual);

                if (progreso < 1) {
                    requestAnimationFrame(animar);
                } else {
                    // Aplicar transformaci√≥n final
                    grupo.rotation.set(0, 0, 0);
                    grupo.rotateOnAxis(eje, anguloTotal);
                    grupo.updateMatrixWorld(true);

                    // Reubicar cubitos en la escena con posici√≥n y rotaci√≥n global
                    cara.forEach(c => {
                        c.updateMatrixWorld(true);

                        const posicionGlobal = new THREE.Vector3();
                        posicionGlobal.setFromMatrixPosition(c.matrixWorld);

                        const quaternionGlobal = new THREE.Quaternion();
                        quaternionGlobal.setFromRotationMatrix(c.matrixWorld);

                        c.position.copy(posicionGlobal);
                        c.quaternion.copy(quaternionGlobal);

                        grupo.remove(c);
                        scene.add(c);
                    });

                    grupo.clear();
                    scene.remove(grupo);
                }
            }

            animar();
        }

       
        function rotarCuboCompleto(movimiento) {
            const grupo = new THREE.Group();

            // Calcular centro del cubo
            const centro = new THREE.Vector3();
            cubitos.forEach(c => centro.add(c.position));
            centro.divideScalar(cubitos.length);
            grupo.position.copy(centro);
            scene.add(grupo);

            // A√±adir cubitos al grupo con posici√≥n relativa
            cubitos.forEach(c => {
                c.updateMatrixWorld(true);
                c.position.sub(centro); // trasladar al origen del grupo
                grupo.add(c);
                scene.remove(c);
            });

            // Eje y sentido
            let eje = new THREE.Vector3();
            let sentidoHorario = true;

            switch (movimiento) {
                case 'R': eje.set(1, 0, 0); break;
                case "R'": eje.set(1, 0, 0); sentidoHorario = false; break;
                case 'U': eje.set(0, 1, 0); break;
                case "U'": eje.set(0, 1, 0); sentidoHorario = false; break;
                case 'F': eje.set(0, 0, 1); break;
                case "F'": eje.set(0, 0, 1); sentidoHorario = false; break;
                default: return;
            }

            const anguloTotal = sentidoHorario ? -Math.PI / 2 : Math.PI / 2;
            const duracion = moveTime;
            const inicio = Date.now();

            function animar() {
                const ahora = Date.now();
                const progreso = Math.min((ahora - inicio) / duracion, 1);
                const anguloActual = anguloTotal * progreso;

                grupo.rotation.set(0, 0, 0);
                grupo.rotateOnAxis(eje, anguloActual);

                if (progreso < 1) {
                    requestAnimationFrame(animar);
                } else {
                    grupo.rotation.set(0, 0, 0);
                    grupo.rotateOnAxis(eje, anguloTotal);
                    grupo.updateMatrixWorld(true);

                    cubitos.forEach(c => {
                        c.updateMatrixWorld(true);

                        const posicionGlobal = new THREE.Vector3();
                        posicionGlobal.setFromMatrixPosition(c.matrixWorld);

                        const quaternionGlobal = new THREE.Quaternion();
                        quaternionGlobal.setFromRotationMatrix(c.matrixWorld);

                        c.position.copy(posicionGlobal);
                        c.quaternion.copy(quaternionGlobal);

                        grupo.remove(c);
                        scene.add(c);
                    });

                    grupo.clear();
                    scene.remove(grupo);
                }
            }

            animar();
        }




        for (let x = -1; x <= 0; x++) {
            for (let y = -1; y <= 0; y++) {
                for (let z = -1; z <= 0; z++) {
                    const geometry = new THREE.BoxGeometry(size, size, size);

                    const materials = [
                        new THREE.MeshBasicMaterial({ color: '#007bff' }), // derecha ‚Üí azul
                        new THREE.MeshBasicMaterial({ color: '#00c853' }), // izquierda ‚Üí verde
                        new THREE.MeshBasicMaterial({ color: '#ffffff' }), // arriba ‚Üí blanco
                        new THREE.MeshBasicMaterial({ color: '#ffe600' }), // abajo ‚Üí amarillo
                        new THREE.MeshBasicMaterial({ color: '#d50000' }), // frente ‚Üí rojo
                        new THREE.MeshBasicMaterial({ color: '#ff6d00' })  // atr√°s ‚Üí naranja
                    ];

                    const cubito = new THREE.Mesh(geometry, materials);
                    cubito.position.set(x * offset, y * offset, z * offset);
                    scene.add(cubito);
                    cubitos.push(cubito);
                }
            }
        }


        /* ==== VARIABLES GLOBALES ==== */
        const movimientos = ['U', 'D', 'R', 'L', 'F', 'B']; // Notaci√≥n b√°sica
        const camaraBotones = [
            { label: '‚Üê', atajo: '‚Üê' },
            { label: '‚Üí', atajo: '‚Üí' },
            { label: '‚Üë', atajo: '‚Üë' },
            { label: '‚Üì', atajo: '‚Üì' },
            { label: '‚Ü∫', atajo: 'Num 4' },
            { label: '‚Üª', atajo: 'Num 6' }
        ];
        let modoPrima = false;    // Si est√° activado el `'` en la notaci√≥n
        let mostrarAtajos = false; // Mostrar/ocultar teclas r√°pidas
        let cooldownActivo = false;
        let cooldownDuracion = moveTime; // milisegundos

        

        const contenedor = document.getElementById('notacion-botones');

        
        /* ==== RENDER DE BOTONES DE NOTACI√ìN ==== */
        function renderBotones() {
            contenedor.innerHTML = '';

            movimientos.forEach(mov => {
                const btn = document.createElement('button');
                btn.setAttribute('data-movimiento', mov);

                // Texto principal del bot√≥n
                const texto = document.createElement('div');
                texto.textContent = modoPrima ? `${mov}'` : mov;
                btn.appendChild(texto);

                // Mostrar atajo si est√° activado
                if (mostrarAtajos) {
                    const atajo = document.createElement('span');
                    atajo.textContent = `Tecla: ${mov}`;
                    atajo.style.display = 'block';
                    atajo.style.fontSize = '12px';
                    atajo.style.color = '#666';
                    atajo.style.marginTop = '4px';
                    btn.appendChild(atajo);
                }

                // üî• Aqu√≠ agregamos el listener con cooldown
                btn.addEventListener('click', () => {
                    if (cooldownActivo) return;

                    cooldownActivo = true;
                    const sentidoHorario = !modoPrima;
                    rotarCara(mov, sentidoHorario);

                    setTimeout(() => {
                        cooldownActivo = false;
                    }, cooldownDuracion);
                });

                contenedor.appendChild(btn);
            });

            // Bot√≥n especial para alternar modo prima
            const btnPrima = document.createElement('button');
            btnPrima.addEventListener('click', () => {
                modoPrima = !modoPrima;
                renderBotones();
            });

            const textoPrima = document.createElement('div');
            textoPrima.textContent = '‚Ä≤';
            btnPrima.appendChild(textoPrima);

            if (mostrarAtajos) {
                const atajo = document.createElement('span');
                atajo.textContent = 'Tecla: Espacio';
                atajo.style.display = 'block';
                atajo.style.fontSize = '12px';
                atajo.style.color = '#666';
                atajo.style.marginTop = '4px';
                btnPrima.appendChild(atajo);
            }

            contenedor.appendChild(btnPrima);
        }


        /* ==== RENDER DE BOTONES DE C√ÅMARA ==== */
        function renderBotonesCamara() {
            const camaraContenedor = document.getElementById('camara-botones');
            camaraContenedor.innerHTML = '';

            const camaraBotones = [
                { label: '‚Üê', atajo: 'ArrowLeft', movimiento: 'U' },
                { label: '‚Üí', atajo: 'ArrowRight', movimiento: "U'" },
                { label: '‚Üë', atajo: 'ArrowUp', movimiento: 'R' },
                { label: '‚Üì', atajo: 'ArrowDown', movimiento: "R'" },
                { label: '‚Ü∫', atajo: 'Numpad4', movimiento: "F'" },
                { label: '‚Üª', atajo: 'Numpad6', movimiento: 'F' }
            ];

            camaraBotones.forEach(({ label, atajo, movimiento }) => {
                const btn = document.createElement('button');

                const texto = document.createElement('div');
                texto.textContent = label;
                btn.appendChild(texto);

                if (mostrarAtajos) {
                    const span = document.createElement('span');
                    span.textContent = `Tecla: ${atajo}`;
                    span.style.display = 'block';
                    span.style.fontSize = '12px';
                    span.style.color = '#666';
                    span.style.marginTop = '4px';
                    btn.appendChild(span);
                }

                // üî• Listener con cooldown para rotar el cubo completo
                btn.addEventListener('click', () => {
                    if (cooldownActivo) return;

                    cooldownActivo = true;
                    rotarCuboCompleto(movimiento);

                    setTimeout(() => {
                        cooldownActivo = false;
                    }, cooldownDuracion);
                });

                camaraContenedor.appendChild(btn);
            });
        }





        /* ==== RENDER DE BOTONES DE UTILIDADES ==== */
        function renderBotonesUtilidad() {
            const utilidadContenedor = document.getElementById('utilidad-botones');
            utilidadContenedor.innerHTML = '';

            const botones = [
                { label: '‚è± Timer', id: 'timer' },
                { label: 'Revolver', id: 'revolver' },
                { label: 'Resolver', id: 'resolver' }
            ];

            botones.forEach(({ label, id }) => {
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.id = `util-${id}`;

                // Timer se activa/desactiva, los dem√°s son placeholders
                if (id === 'timer') {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('activo');
                    });
                } else {
                    btn.addEventListener('click', () => {
                        alert(`${label} a√∫n no est√° implementado`);
                    });
                }

                utilidadContenedor.appendChild(btn);
            });
        }

        /* ==== EVENTOS DE TECLADO ==== */
        document.addEventListener('keydown', (event) => {
            const tecla = event.key.toUpperCase();

            // Alternar prima con barra espaciadora
            if (event.code === 'Space') {
                event.preventDefault();
                modoPrima = !modoPrima;
                renderBotones();
                return;
            }

            // Movimientos de capas (U, D, R, L, F, B)
            if (movimientos.includes(tecla)) {
                if (cooldownActivo) return;

                cooldownActivo = true;
                const sentidoHorario = !modoPrima;
                rotarCara(tecla, sentidoHorario);

                setTimeout(() => {
                    cooldownActivo = false;
                }, cooldownDuracion);

                return;
            }

            // Controles de c√°mara ‚Üí girar el cubo completo
            if (cooldownActivo) return;

            let movimientoGlobal = null;

            switch (event.code) {
                case 'ArrowLeft':
                    movimientoGlobal = 'U';     // girar cubo a la izquierda
                    break;
                case 'ArrowRight':
                    movimientoGlobal = "U'";    // girar cubo a la derecha
                    break;
                case 'ArrowUp':
                    movimientoGlobal = 'R';     // girar cubo hacia arriba
                    break;
                case 'ArrowDown':
                    movimientoGlobal = "R'";    // girar cubo hacia abajo
                    break;
                case 'Numpad4':
                    movimientoGlobal = "F'";     // rotar cubo hacia la derecha
                    break;
                case 'Numpad6':
                    movimientoGlobal = 'F';    // rotar cubo hacia la izquierda
                    break;
            }

            if (movimientoGlobal) {
                cooldownActivo = true;
                rotarCuboCompleto(movimientoGlobal);

                setTimeout(() => {
                    cooldownActivo = false;
                }, cooldownDuracion);
            }
        });


        /* ==== INICIALIZACIONES ==== */
        renderBotones();
        renderBotonesCamara();
        renderBotonesUtilidad();

        /* ==== MANEJO DE MINI-VENTANA ==== */
        const miniVentana = document.getElementById('miniVentana');
        const toggleVentana = document.getElementById('toggleVentana');
        let ventanaMinimizada = false;

        toggleVentana.addEventListener('click', () => {
            ventanaMinimizada = !ventanaMinimizada;

            if (ventanaMinimizada) {
                miniVentana.style.height = '30px';
                toggleVentana.textContent = '>';
            } else {
                miniVentana.style.height = '270px';
                toggleVentana.textContent = 'v';
            }
        });

        /* ==== BOT√ìN MOSTRAR/OCULTAR ATAJOS ==== */
        const verAtajosBtn = document.getElementById('verAtajosBtn');
        verAtajosBtn.addEventListener('click', () => {
            mostrarAtajos = !mostrarAtajos;
            verAtajosBtn.textContent = mostrarAtajos ? 'Ocultar atajos' : 'Ver atajos';

            renderBotones();
            renderBotonesCamara();
            
        });

        // CheckBox
        const movimientoCheckbox = document.getElementById('movimientoCheckbox');
  

        movimientoCheckbox.addEventListener('change', () => {

            if (movimientoCheckbox.checked) {
                moveTime = 50;
                cooldownDuracion = 70;
                
            } else {
                moveTime = 400;
                cooldownDuracion = 410;

            }
        });

    </script>
</body>
</html>
